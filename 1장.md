# 1장. 함수를 이용한 추상화

이번 장에서 공부할 내용은 계산적 과정 ( computational process )

초보 프래그래머는 자신이 불러낸 과정이 어떤 일을 하는지 이해하고 예측하는 방법을 배워야 한다.
-> 자신이 작성한 코드를 이해해야 된다는 의미. 무슨 일을 하고 있는지 이해한 상태에서 해야한다.

잘 설계된 계산적 시스템은 모듈식으로, 그러니까 개별 부품을 따로 작성, 교체, 디버깅할 수 있는 형태로 만들어진다.
-> 낮은 결합도와 높은 응집도를 가져야한다 라는 의미와 비슷하게 이해됨.

## 자바스크립트 프로그램

자바스크립트로 서술된 계산 과정은 자바스크립트 해석기(interpreter) 라고 부르는 프로그램이 수행한다.

## 1.1 프로그래밍 기본 요소

프로그래밍 언어는 우리가 과정에 대한 생각들을 조직화 하는 틀로도 작용한다.

생각을 조직화 하기 위해서 필요한 요소들이 무엇일까? 단순한 작은 단위의 아이디어들을 조합해서 보다 복잡하고 큰 아이디어를 만들어낼 수 있는 수단이 필요하다.

프로그래밍 언어들은 이를 위해 다음과 같은 수단을 제공한다.

- 원시 표현식: 언어와 관련한 가장 단순한 개체를 나타낸다.
- 조합 수단: 단순한 요소들로 복합적인 요소를 만드는데 사용
- 추상화 수단: 복합적인 요소들에 이름을 붙여서 하나의 단위로 다루는 데 사용

프로그래밍에서 우리가 다루는 요(element)들은 크게 함수와 데이터로 나뉜다. ( 물론 이 둘이 아주 명백하게 구분되는 것은 아니라는 점을 공부할수록 더 알게 된다.)

Rough 하게 비유하자면, 데이터는 조작하고자 하는 재료이고 함수는 데이터를 다루는 규칙을 서술한 것이라고 볼 수 있다.

원시 데이터와 원시 함수를 서술하고 이를 조합해서 추상화 하는 수단들을 가지고 계산적 과정을 만들어 갈 수 있다고 보면 되는 듯.

### 1.1.1 표현식

다음은 십진수를 나타내는 표현식이다

```javascscript
// 표현식 문장은 표현식과 세미콜론으로 구성된다.
486;

// 자바스크립트 해석기는 위 표현식을 입력받아 다음의 평가 결과를 출력한다.
486
```

해석기는 항상 동일한 기본 주기 (cycle) 로 동작한다.

READ -> EVALUATE -> PRINT ( REPL - Read Evaluate Print loop)

### 1.1.2 이름 붙이기와 환경

상수 선언은 프로그래밍 언어에서 제공하는 가능 단순한 형태의 추상화 수단이다.
-> 특정 연산의 결과를 간단한, 해당 계산의 특징을 반영하는 이름으로 지칭할 수 있다는 점에서.

```javascript
// 아래와 같이 특정 값들의 연산을 하나의 상수로 지칭하여 값을 활용하는데 사용할 수 있다.

const pi = 3.14159;

const radius = 10;

const circumference = 2 * pi * radius;
```

복잡한 프로그램은 점차 더 복잡한 계산적 객체 ( computational object )들을 구축해나가는 식으로 만들어진다.
-> 단순한 조각들을 합쳐서 보다 큰 단위의 무언가를 만들고, 이들을 또 조합해서 무언가를 만드는 형태를 지칭하는 것으로 보임

이름과 값을 연관시키고, 이름으로부터 값을 조회하려면 해석기는 이름-객체 쌍을 저장하고 관리하는 메모리 공간이 필요하다. 그러한 메모리 공간을 **환경** 이라고 부른다. ( 하나의 계산에 다수의 환경이 관여하는 경우도 있으므로, 지금 말하는 환경은 정확하게 말하자면 **프로그램 환경**이다.)
-> `다수의 환경이 관여한다` 라는 것이 어떤 의미인지?

### 1.1.3 연산자 조합의 평가

해석기는 연산자 조합을 평가할 때, 다음과 같은 절차를 따른다.

1. 조합의 피연산자 표현식들을 평가
2. 연산자가 나타내는 함수를 인수(피연산자들의 값)들에 적용

일견 단순해 보이는 이 절차는 계산적인 과정에 관련해서 일반적으로 중요한 사항 몇 가지를 잘 보여준다.

첫 번째로, 단계 1은 조합의 평가 과정을 완료하기 위해서는 조합의 각 피연산자를 평가해야 한다는 사실을 말한다. 즉, 피연산자들에 대해서 위 절차를 다시 수행하는 재귀적인 형태의 처리가 필요하다는 의미.

`재귀` 라는 개념 덕분에 깊게 중첩된 평가 규칙도 간결하게 (같은 로직을 반복 수행하는 방식으로) 표현할 수 있다.

```javascript
// 아래의 연산자 조합을 보자.
// 연산자 조합 - 표현식들을 연산자로 합친 조합을 의미한다.

(2 + 4 * 6) * (3 + 12);

// 위 연산자 조합을 평가하기 위해서는 서로 다른 네 가지 조합에 평가 규칙을 적용해야 한다.
// 1. 4 * 6
// 2. 2 + (4*6)
// 3. 3 + 12
// 4. 2번 평가결과 * 3번 평가결과
```

위 연산자 조합의 평가 과정은 트리 형태로 시각화할 수 있다.

조합의 평가 과정은 말단 노드에서 피연산자 값들을 해당 연산자에 따라 결합해서 점차 위로 올려보내는 과정이다. 재귀는 이처럼 트리 형태의 위계구조로 조직화된 객체들과 관련된 처리를 하는데 아주 좋은 강력한 기법이다.

참고로, _값들을 위로 올려보내는_ 형태의 평가 규칙은 **트리 누산** 이라고 부르는 일반적인 과정의 한 예시이다.

재귀에는 종료조건이 필요한데, 이 트리 같은 경우 단계 1(조합의 피연산자 표현식을 평가한다.)을 반복하다 보면 언젠간 조합이 아니라 원시 표현식(수치 or 이름)을 평가하는 지점에 도달하는 것이 종료조건이라고 볼 수 있겠다.

원시 표현식의 평가에는 다음과 같은 규칙이 적용된다.

- 해당 값이 plain 수치값인 경우, 해당 숫자가 바로 그 값임
- 이름인 경우, 현재 환경에서 이름에 연결된 메모리 주소에 저장된 객체 or 값임

표현식 안의 이름이 뜻하는 바는 **환경**에 의해서 결정된다.
-> `x + 1` 이라는 표현식을 평가하기 위해선, x 라는 이름이 무엇을 의미하는지 제공하는 환경에 대한 정보가 필요하다. 평가가 일어나는 문맥(context)을 제공하는 환경이 어딘지, 무엇인지 해석기가 인지하고 있어야 해당 환경의 메모리 구조를 검색해 해당 이름에 연관된 값 or 객체를 사용할 수 있음

여기서 한 가지 특이한 점은, 위 평가 규칙이 값 선언에는 적용되지 않는다는 점.
-> const x = 3; 과 같은 표현식은 평가할 때 연산자 조합으로 평가하지 않는다. `**선언**` 은 이름을 값에 연관시키는 것만을 목적으로 하는 특별한 종류의 프로그램 구성 요소.

### 1.1.4 복합 함수

함수 선언은 `복합 연산에 이름을 붙여서 그 연산을 하나의 단위로 지칭하는 수단` 이라고 볼 수 있다. 복잡한 연산을 하나의 단위로 묶어서 추상화가 가능하기 때문에, 상수 선언보다 더 강력한 추상화 기법.

```javascript
// 아래의 함수 선언은 두 가지 연산의 조합이다.

// 1. 함수 자체를 생성
// 2. square 라는 이름 부여

function square(num) {
  return num * num;
}
```

### 1.1.5 함수 적용의 치환 모형

치환 모형이라는 형식 자체는, 평가 과정을 형식적으로 인지하는데 익숙해지는데 도움을 주고자 하는 모형이다. 즉 해석기가 실제로 동작하는 방식과는 다를 수 있다.

해석기는 매개변수에 대한 지역 환경을 이용해서 `치환`을 처리한다.

#### 인수 우선 평가 vs 정상 순서 평가

해석기가 함수와 인수 표현식을 먼저 평가하고, 그 결과로 얻은 함수를 인수들에 적용하는 순서의 평가 수행 순서는 유일한 방법은 아니다.

인수의 값이 실제로 필요할 때 까지 인수 표현식의 평가를 미루는 평가 모형도 가능함.

먼저 인수들을 다 평가한 후에, 함수 로직의 매개변수를 인수로 치환해서 계산하는 방법은 `**인수 우선 평가 or 적용적 순서 평가(applicative-order evaluation**`라고 한다.

반대로, 완전히 먼저 전개한 후에 축약하는 형태로 평가 하는 방식을 `**정상 순서 평가(normal-order evaluation**` 이라고 한다.

자바스크립트는 인수 우선 평가 방식을 사용한다. 물론, 인수를 먼저 평가하면 해당 인수 표현식을 여러 번 중복평가 하는 비효율을 피하는 것도 하나의 이유이다.
-> 하지만 보다 근본적인 이유는, 평범한 치환 모형을 벗어난 함수들을 평가하는 경우 정상 순서 평가가 훨씬 복잡하기 때문이다. 물론 정상 평가 순서가 더 좋은 도구인 경우들도 존재한다.

### 1.1.6 조건부 표현식과 술어

아래 조건부 표현식이 포함된 함수를 살펴보자.ㅏ

```javascript
function abs(x) {
  return x >= 0 ? x : -x;
}
```

조건부 표현식은 술어(predicate)로 시작한다.

`x >= 0` 은 값이 true or false 로 평가될 수 있는 표현식이다.

술어가 참인 경우, 귀결 표현식(x)으로 조건 표현식 전체의 값으로 반환
술어가 거짓인 경우, 대안 표현식(-x)으로 조건 표현식 전체의 값으로 반환

&& 와 || 는 연산자가 아니라 구문형이다. 연산자는 피연산자 표현식들을 항상 평가하지만, 이들은 우변에 오는 표현식이 항상 평가되지는 않는다.

### 연습문제

#### 1.5 해석기가 인수 우선 평가를 사용하는지, 정상 순서 평가를 사용하는지 파악하는 방법에 관련된 문제

### 1.1.7 예제: 뉴턴 방법으로 제곱근 구하기

일반적인 수학 함수와, 컴퓨터 함수에는 중요한 차이점이 존재한다.

컴퓨터 함수는 효과적(effective) 해야 한다는 점.

제곱근을 구하는 문제에 대해서 수학적 서술과, 프로그래밍적 서술을 비교해보자.

수학적으로 제곱근을 구하는 방법은 루트라는 기호과, 해당 기호에 대한 정의로 표현할 수 있다.

`루트 x = y >= 0 이고 y^2 = x라는 조건을 충족하는 y`

수학적으로는 완벽하지만, 이 정의를 보면 실제로 제곱근을 구하는 방법에 대해서는 아무것도 서술되어 있지 않다.

수학적으로 표현할 때는 사물의 성질을 표현하지만, 프로그래밍적으로는 무엇을 어떻게 하는지에 대해서 서술해야 한다.

이를 선언적 지식과 명령형 지식의 차이라고도 표현.

컴퓨터 과학에서는 주로 명령적 저술 (어떻게 하는지?)에 관심을 둔다.
-> 선언적 문장들로 실제 프로그램을 짤 수 있는 언어가 고수준 언어구나. 그리고 선언적으로 프로그래밍 한다는 것의 의미를 조금 더 이해할 것 같기도 하다. 컴퓨터는 구조상 선언적인 문장 그 자체를 해석해주지 않으면 처리를 할 수 없다. 프로그래머가 겉으로 보기에는 선언적으로 프로그래밍을 하더라도, 결국 이는 명령적 프로그래밍이 추상화 되어 있는 형태인 것인 듯.

제곱근은 어떻게 계산할 수 있을까?

가장 흔히 쓰이는 방법은 뉴턴 방법 -> 제곱근의 근사값을 반복적으로 계산하는 것이다.

수 x의 제곱근이 될 만한 y값을 추측하고, y와 x/y 의 평균으로 더 나은 추측값을 계산하는 과정을 반복.

이런 과정을 자바스크립트 함수로 표현해보자.
-> 1.js 파일에서 구현하였음

조건부로 함수가 본인을 재호출함으로써 반복문 없이도 반복적인 로직 수행이 가능하도록 만들었음.

### 1.1.8 블랙박스 추상으로서의 함수

위에서 처리한 `get_sqrt` (책에서의 이름은 sqrt)함수는 하나의 과정(계산적 과정 -> 여기서는 제곱근을 구하는 과정이겠지)을 서로 연관된 일련의 함수들로 정의하는 예시이다.

일련의 함수들로 이루어져있다는 것은, 관념적으로 보면 하나의 문제가 여러 부분 문제로 분해되어 해결되고 있다는 의미이다.
함수를 작은 문제를 해결하는 함수로 분해하는 작업은 단순히 여러 부분으로 나누는 것에 의미가 있는 것이 아니라, 각 함수가 해결하는 식별 가능한 과제를 명확하게 설정하여 필요하다면 해당 함수가 각각의 `module` 로 필요한 곳에서 사용될 수 있도록 하는 것.

함수는 일종의 블랙박스와 같은 성격을 가지도록 구현해야 한다.
-> 풀어서 말하자면, 함수는 세부사항을 숨기고 세부사항을 몰라도 사용할 수 있어야 한다.

음 하나의 사례를 가볍게 생각해서 만들어보자.

```javascript
// 사용자가 수행한 운동 기록을 토대로 해당 운동의 1rm을 예측하는 함수라고 생각해보자.

function calc_1rm(workoutName) {
  const weightAverage = calc_workout_weight_average(workoutName);
  const repstAverage = calc_workout_reps_average(workoutName);

  return weightAverage * repsAverage; // some sort of calculation
}

// 이 경우에, 1rm 을 계산하는 함수는 무게 평균과 횟수 평균을 구하는 부분 문제를 해결하는 함수로 조합되어 있다. 그리고 사용자는 이러한 세부사항을 알지 못하더라도 함수만을 가지고 1rm을 구할 수 있다.
```

블랙박스 형태로 함수를 추상화 하는데 있어서 도움이 되는 몇 가지 포인트에 대해서 `get_sqrt` 함수를 기준으로 생각해보자ㅏ.

- 함수의 매개변수는 함수 내에서만 유효한 범위를 가진다. 즉 scoping 효과가 있다.
- 기존에 `get_sqrt` 함수에서, 문제점 한 가지는 바로 `사용자에게는 get_sqrt 함수만 중요하다` 라는 점이다. 무슨 소리인고 하니, 사용자가 결국 사용하고자 하는 함수는 `get_sqrt`함수 뿐이고, `get_sqrt` 함수를 구현하기 위해 정의된 부분함수들은 따로 사용할 필요가 없다는 점이다. (따로 사용할 수 없게 해야된다 라는 것이 더 맞는 표현일지도 모르겠다.)
- 만약에 부분함수들이 (결국 부분함수들도 하나의 변수에 담겨있는 데이터라고 봤을 때)`get_sqrt` 함수 블록 내 지역 변수가 아니라, `get_sqrt`로부터 자유로운 별개의 함수로 존재하는 경우 이와 비슷한 기능을 하는 다른 함수를 선언했을 때 다양한 이슈가 생길 가능성이 큼.
- 그럼으로 `get_sqrt` 함수만 자유변수로 두고, 나머지 부분함수들은 `get_sqrt`함수의 지역변수로 선언해서 사용하는 형태가 조금 더 *추상화*된 버전이라고 볼 수도 있겠다.
- 그리고 이렇게 처리하면, 함수들이 매개변수로 받았어야 하는 값을 블록 내 지역 변수로 따로 선언하여 블록 내에서 전역 변수처럼 공유해서 사용이 가능하다. (x 값을 명시적으로 매개변수로 함수에 전달하는 것이 아니라, 같은 변수를 공유해서 참조하는 형태로 구현이 가능하다. )
- 블록 구조는 큰 프로그램을 이해가능 한 쉬운 조각들로 나누는데 중요한 기법 중 하나.
