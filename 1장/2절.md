### 1.2 함수와 과정(함수가 생성하는)

여기까지 공부했다고 해서 바로 프로그램을 뚝딱 하고 만들어낼 수 있을까? 아니다.

체스로 따지면 각 말이 어떻게 이동하는 지만 배운 상태라고 볼 수 있음. 체스에서 승리하기 위해서 필요한 각 말을 언제 어떻게 활용해야 하는지, 어떤 전략들이 존재하는지 등 일반적인 사용법과 보다 큰 전략적인 그림에 대한 이해가 추가로 필요한 상태

어떤 수가 가치가 있는 수인지, 어떤 수를 두는 것이 어떤 결과를 야기할지 등에 대한 경험이 부족함

함수를 통해 생성되는 과정의 몇 가지 공통된 형태를 살펴보고, 관련해서 시간/공간적으로 얼마나 계산 자원이 소비되는지도 알아보자.

#### 1.2.1 선형 재귀와 반복

**선형 재귀적 과정**

예시 -> factorial 을 n! = n \* (n-1)! 이라는 점에 착안해서 로직을 작성해서 푸는 과정

```javascript
function get_fact_recursive(n) {
  if (n > 1) return n * get_fact_recursive(n - 1);
  return 1;
}
```

위 방식의 과정을 단계별로 보면,

`get_fact_recursive(4)`

= `4 * get_fact_recursive(3)`

= `4 * (3 * get_fact_recursive(2))`

= `4 * (3 * (2 * get_fact_recursive(1)))`

= `4 * (3 * (2 * 1))`

-> 전개하면서 계산

이런 순서로 과정이 전개된다.

즉, 표현식이 완전히 전개된 후에 최종 결과를 향해 다시 축약된다.

전개 -> 계산적 과정이 지연된 연산들의 사슬을 구축하면서 일어난다.
-> 내가 이해한 바가 맞다면, 연산 자체는 바로 일어나지 않고, 연산 chaining 이 쭉 마지막 종료조건에 의해서 함수의 재귀적 호출이 종료될때까지 전개가 되고 연산은 지연된다는 의미

여기서 중요한 포인트는, 이러한 **지연된 연산** 들은 말그대로 지연되었을 뿐 언젠간 수행되어야 한다는 점이다. 즉 해석기가 이 함수 호출을 최종적으로 마무리 하기 위해서는 지연된 연산들이 어딘가에 기억되어 있어야 한다.

n! 을 계산할 때 지연된 곱셉 사슬의 길이는 n에 선형적으로 비례한다. (n이 증가함에 따라 사슬의 길이도 당연히 비례해서 선형적으로 증가한다.)

그래서 이런 재귀적 과정을 `**선형 재귀적 과정**` 이라고 부름

**선형 반복적 과정**

예시 -> factorial 을 1부터 n까지 곱하면 된다는 점에 착안하여, 특정 변수값이 n 이 될때까지 1씩 증가시키며 곱하여 결과를 구하는 과정

```javascript
function get_fact_linear(n) {
  const maxCount = n;
  let currentNumber = 0;
  let result = 1;

  function linear_func(prevResult, curNumber) {
    curNumber++;

    return curNumber === maxCount
      ? prevResult * curNumber
      : linear_func(prevResult * curNumber, curNumber);
  }
}
```

위 방식이 전개되는 과정은 다음과 같다.

`get_fact_linear(4)`

= `linear_func(1, 0)`
= `linear_func(1, 1)`
= `linear_func(2, 2)`
= `linear_func(6, 3)` // 여기서 maxCount 와 동일한 값이 되므로 6 \* return
= `24`

재귀적 과정과 비교했을 때, 반복적 과정은 전개되거나 축약되는 것이 아니라 변수의 값만 변경되면서 같은 함수가 실행되면 된다.

메모리가 선형적으로 늘어날 필요가 없고, 고정된 메모리 공간만 필요하다.

두 방식은 또한 이런 점에서도 차이가 있다.

반복적 과정에서 상태 변수들은 과정이 어디에 있는지, 어느 단계에 있는지를 담고 있는 진행도를 보여주는 값으로도 활용될 수 있다. 해당 값들만 어딘가에 저장해둔다면, 비정상적으로 종료되거나한 이후에도 연산을 중단된 시점으로부터 이어나갈 수 있다.

반면에 재귀적 과정은 해석기가 전개/축약과정을 처리하기 위해서 자체적으로 관리하는 숨겨진 정보가 존재한다. 이 정보는 지연된 연산 처리 시 과정이 어떤 단계에 있는지 나타내고, 이 정보는 사슬의 길이에 비례해서 늘어난다.
